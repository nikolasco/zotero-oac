<?xml version="1.0"?>
<!--
    ***** BEGIN LICENSE BLOCK *****
    
    Copyright (c) 2006  Center for History and New Media
                        George Mason University, Fairfax, Virginia, USA
                        http://chnm.gmu.edu
    
    Licensed under the Educational Community License, Version 1.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
    http://www.opensource.org/licenses/ecl1.php
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    
    ***** END LICENSE BLOCK *****
-->
<?xml-stylesheet href="chrome://zotero/skin/overlay.css" type="text/css"?>
<!DOCTYPE bindings SYSTEM "chrome://zotero/locale/zotero.dtd">

<bindings xmlns="http://www.mozilla.org/xbl"
		  xmlns:xbl="http://www.mozilla.org/xbl"
		  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

	<binding id="tag-selector">
		<resources>
			<stylesheet src="chrome://zotero/skin/bindings/tagselector.css"/>
		</resources>
		
		<implementation>
			<field name="_initialized">false</field>
			<field name="_notifierID">false</field>
			<field name="_tags">null</field>
			<field name="_dirty">null</field>
			<field name="selection"/>
			
			<field name="_hasFilter">false</field>
			<field name="_filter">null</field>
			<method name="setFilterTags">
				<parameter name="val"/>
				<parameter name="skipRefresh"/>
				<body>
				<![CDATA[
					if (Zotero.hasValues(val)) {
						this._hasFilter = true;
						this._filter = val;
					}
					else {
						this._hasFilter = !!val;
						this._filter = {};
					}
					
					if (!skipRefresh) {
						this.refresh();
					}
				]]>
				</body>
			</method>
			
			<field name="_hasScope">false</field>
			<field name="_scope">null</field>
			<property name="scope" onget="return this._scope">
				<setter>
				<![CDATA[
					if (Zotero.hasValues(val)) {
						this._hasScope = true;
						this._scope = val;
					}
					else {
						this._hasScope = !!val;
						this._scope = {};
					}
					
					this.refresh();
				]]>
				</setter>
			</property>
			
			<property name="filterToScope">
				<getter>
				<![CDATA[
					return this.getAttribute('filterToScope') == 'true';
				]]>
				</getter>
				<setter>
				<![CDATA[
					this.setAttribute('filterToScope', val);
					this.refresh();
				]]>
				</setter>
			</property>
			
			<constructor>
				<![CDATA[
					this.setAttribute('filterToScope', true);
					this.dragObserver = new this._dragObserverConstructor;
				]]>
			</constructor>
			
			
			<method name="init">
				<body>
				<![CDATA[
					this._initialized = true;
					this.selection = {};
					this._notifierID = Zotero.Notifier.registerObserver(this);
				]]>
				</body>
			</method>
			
			
			<method name="uninit">
				<body>
				<![CDATA[
					if (!this._initialized) {
						return;
					}
					
					this._initialized = false;
					this.unregister();
					this.selection = {};
					this.doCommand();
				]]>
				</body>
			</method>
			
			
			<method name="unregister">
				<body>
				<![CDATA[
					if (this._notifierID) {
						Zotero.Notifier.unregisterObserver(this._notifierID);
					}
				]]>
				</body>
			</method>
			
			
			<method name="refresh">
				<parameter name="fetch"/>
				<body>
				<![CDATA[
					if (!this._initialized) {
						this.init();
						fetch = true;
					}
					
					Zotero.debug('Refreshing tags selector');
					var tagsToggleBox = this.id('tags-toggle');
					
					if (fetch || this._dirty) {
						this._tags = Zotero.Tags.getAll();
						
						// Remove children
						while (tagsToggleBox.hasChildNodes()){
							tagsToggleBox.removeChild(tagsToggleBox.firstChild);
						}
						
						// Regenerate list
						for (var tagID in this._tags) {
							var label = document.createElement('label');
							label.setAttribute('onclick', "this.parentNode.parentNode.parentNode.handleTagClick(this)");
							label.className = 'zotero-clicky';
							label.setAttribute('value', this._tags[tagID]);
							label.setAttribute('tagID', tagID);
							label.setAttribute('context', 'tag-menu');
							label.setAttribute('ondragover', 'nsDragAndDrop.dragOver(event, this.parentNode.parentNode.parentNode.dragObserver)');
							label.setAttribute('ondragexit', 'nsDragAndDrop.dragExit(event, this.parentNode.parentNode.parentNode.dragObserver)');
							label.setAttribute('ondragdrop', 'nsDragAndDrop.drop(event, this.parentNode.parentNode.parentNode.dragObserver)');
							tagsToggleBox.appendChild(label);
						}
						
						this._dirty = false;
					}
					
					// Set attributes
					var labels = tagsToggleBox.getElementsByTagName('label');
					for (var i=0; i<labels.length; i++){
						var tagID = labels[i].getAttribute('tagID');
						
						// Restore selection
						if (this.selection[labels[i].value]){
							labels[i].setAttribute('selected', 'true');
						}
						else {
							labels[i].setAttribute('selected', 'false');
						}
						
						// If not in filter, hide
						if (this._hasFilter && !this._filter[tagID]) {
							//Zotero.debug(1);
							labels[i].setAttribute('hidden', true);
						}
						else if (this.filterToScope) {
							if (this._hasScope && this.scope[tagID]) {
								//Zotero.debug(2);
								labels[i].setAttribute('inScope', true);
								labels[i].setAttribute('hidden', false);
							}
							else {
								//Zotero.debug(3);
								labels[i].setAttribute('hidden', true);
								labels[i].setAttribute('inScope', false);
							}
						}
						// Display all
						else {
							if (this._hasScope && this.scope[tagID]) {
								//Zotero.debug(4);
								labels[i].setAttribute('inScope', true);
							}
							else {
								//Zotero.debug(5);
								labels[i].setAttribute('inScope', false);
							}
							
							labels[i].setAttribute('hidden', false);
						}
					}
				]]>
				</body>
			</method>
			
			
			<method name="notify">
				<parameter name="event"/>
				<parameter name="type"/>
				<parameter name="ids"/>
				<body>
				<![CDATA[
					if (type == 'item') {
						var t = this.id('tags-search').inputField;
						this.setFilterTags(Zotero.Tags.search(t.value), true);
						this._dirty = true;
						this.doCommand();
					}
					
					// TODO: optimize for tag notifications?
					// Would need separate additional Notifier events
					// to distinguish between item adds and item collection adds
					// and for tag changes on items separate from item-modify,
					// plus code to insert new/changed tags at the appropriate spot
					
					return;
				]]>
				</body>
			</method>
			
			
			<method name="selectVisible">
				<body>
					<![CDATA[
						var tagsToggleBox = this.id('tags-toggle');
						
						var labels = tagsToggleBox.getElementsByTagName('label');
						for (var i=0; i<labels.length; i++){
							if (labels[i].getAttribute('hidden') != 'true'
								 && labels[i].getAttribute('inScope') == 'true') {
								labels[i].setAttribute('selected', 'true');
								this.selection[labels[i].value] = true;
							}
						}
					]]>
				</body>
			</method>
			
			
			<method name="clearVisible">
				<body>
					<![CDATA[
						var tagsToggleBox = this.id('tags-toggle');
						
						var labels = tagsToggleBox.getElementsByTagName('label');
						for (var i=0; i<labels.length; i++){
							labels[i].setAttribute('selected', 'false');
							this.selection[labels[i].value] = false;
						}
						
						// Bubbles up to command
					]]>
				</body>
			</method>
			
			
			<method name="clearAll">
				<body>
					<![CDATA[
						this.selection = [];
						this.clearVisible();
					]]>
				</body>
			</method>
			
			
			<method name="handleKeyPress">
				<parameter name="clear"/>
				<body>
					<![CDATA[
						Zotero.debug(clear);	
						
						var textbox = this.id('tags-search');
						var t = textbox.inputField;
						
						textbox.firstChild.hidden = (t.value == "");
						
						if (clear != undefined){
							if (clear){
								t.value = '';
								this.setFilterTags(false);
								return false;
							}
							else {
								return true;
							}
						}
						
						this.setFilterTags(Zotero.Tags.search(t.value));
						return true;
					]]>
				</body>
			</method>
			
			
			<method name="handleTagClick">
				<parameter name="label"/>
				<body>
					<![CDATA[
						// Ignore clicks on tags not in scope
						if (label.getAttribute('inScope') == 'false') {
							return;
						}
						
						// Deselect
						if (label.getAttribute('selected')=='true'){
							this.selection[label.value] = false;
							label.setAttribute('selected', 'false');
						}
						// Select
						else {
							this.selection[label.value] = true;
							label.setAttribute('selected', 'true');
						}
						
						this.doCommand();
					]]>
				</body>
			</method>
			
			
			<method name="rename">
				<parameter name="tagID"/>
				<body>
				<![CDATA[
					var oldName = Zotero.Tags.getName(tagID);
					
					var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
						.getService(Components.interfaces.nsIPromptService);
					
					var newName = { value: oldName };
					var result = promptService.prompt(window,
						Zotero.getString('pane.tagSelector.rename.title'),
						Zotero.getString('pane.tagSelector.rename.message'),
						newName, '', {});
					
					if (result && newName.value)
					{
						Zotero.Tags.rename(tagID, newName.value);
					}
				]]>
				</body>
			</method>
			
			
			<method name="delete">
				<parameter name="tagID"/>
				<body>
				<![CDATA[
					var promptService = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
						.getService(Components.interfaces.nsIPromptService);
					
					var confirmed = promptService.confirm(window,
						Zotero.getString('pane.tagSelector.delete.title'),
						Zotero.getString('pane.tagSelector.delete.message'));
					
					if (confirmed) {
						Zotero.Tags.remove(tagID);
					}
				]]>
				</body>
			</method>
			
			<method name="focusTextbox">
				<body>
					<![CDATA[
						this.id('tags-search').focus();
					]]>
				</body>
			</method>
			
			
			<property name="dragObserver"/>
			<method name="_dragObserverConstructor">
				<body>
				<![CDATA[
					this.onDragOver = onDragOver;
					this.onDragExit = onDragExit;
					this.onDrop = onDrop;
					this.getSupportedFlavours = getSupportedFlavours;
					
					
					function onDragOver(event, flavour, session) {
						event.target.setAttribute('draggedOver', true);
						return true;
					}
					
					function onDragExit(event, session) {
						event.target.setAttribute('draggedOver', false);
						return true;
					}
					
					
					function onDrop(event, dropData, session) {
						event.target.setAttribute('draggedOver', false);
						
						var ids = dropData.data.split(',');
						var items = Zotero.Items.get(ids);
						var unlock = Zotero.Notifier.begin(true);
						for each(var item in items) {
							item.addTagByID(event.target.getAttribute('tagID'));
						}
						Zotero.Notifier.commit(unlock);
					}
					
					
					function getSupportedFlavours() {
						var flavours = new FlavourSet();
						flavours.appendFlavour("zotero/item");
						return flavours;
					}
				]]>
				</body>
			</method>
			
			
			<method name="id">
				<parameter name="id"/>
				<body>
					<![CDATA[
						return document.getAnonymousNodes(this)[0].getElementsByAttribute('id',id)[0];
					]]>
				</body>
			</method>
		</implementation>
		
		<content>
			<xul:groupbox flex="1">
				<xul:menupopup id="tag-menu">
					<xul:menuitem label="&zotero.tagSelector.renameTag;" class="menuitem-non-iconic" oncommand="this.parentNode.parentNode.parentNode.rename(document.popupNode.getAttribute('tagID')); event.stopPropagation()"/>
					<xul:menuitem label="&zotero.tagSelector.deleteTag;" class="menuitem-non-iconic" oncommand="this.parentNode.parentNode.parentNode.delete(document.popupNode.getAttribute('tagID')); event.stopPropagation()"/>
				</xul:menupopup>
				
					<xul:vbox id="tags-toggle" flex="1"/>
					<xul:checkbox label="&zotero.tagSelector.displayAll;"
						oncommand="this.parentNode.parentNode.filterToScope = !this.checked; event.stopPropagation();">
					</xul:checkbox>
					<xul:hbox>
						<xul:label value="&zotero.tagSelector.filter;"/>
						<xul:textbox id="tags-search" flex="1" type="timed" timeout="250" dir="reverse"
							oncommand="this.parentNode.parentNode.parentNode.handleKeyPress(); event.stopPropagation()"
							onkeypress="if (event.keyCode == event.DOM_VK_ESCAPE) { this.parentNode.parentNode.parentNode.handleKeyPress(true); }">
							<xul:toolbarbutton id="search-cancel"
								oncommand="this.parentNode.focus(); this.parentNode.parentNode.parentNode.parentNode.handleKeyPress(true)" hidden="true"/>
						</xul:textbox>
					</xul:hbox>
					<xul:hbox>
						<!--
						Disabled until there's an ANY search mode
						<xul:toolbarbutton label="&zotero.tagSelector.selectVisible;" class="zotero-clicky"
							oncommand="this.parentNode.parentNode.parentNode.selectVisible()"/>-->
						<xul:toolbarbutton label="&zotero.tagSelector.clearVisible;" class="zotero-clicky"
							oncommand="this.parentNode.parentNode.parentNode.clearVisible()"/>
						<xul:toolbarbutton label="&zotero.tagSelector.clearAll;" class="zotero-clicky"
							oncommand="this.parentNode.parentNode.parentNode.clearAll();"/>
					</xul:hbox>
			</xul:groupbox>
		</content>
	</binding>
</bindings>
